//! Parsing expression grammars(PEG) for subset of the Go programming language spec

// TODO:
// 1. Disallow NUL character(U+0000) in the source text
// 2. Ignore a UTF-8-encoded byte order mark (U+FEFF) if it is the first
// Unicode code point in the source text. A byte order mark may be disallowed
// anywhere else in the source.
// 3. consider comment containing newlines as newlines. A general comment containing no
// newlines acts like a space. Any other comment acts like a newline.
// 4. Semicolons

// Questions:
//

/// Source Code Representation
/// Characters

/// escape sequence `\n`
NewLine     = { "\u{000A}" }
UnicodeChar = { !(NewLine) ~ ANY }
// refer:
// 1. https://pest.rs/book/grammars/built-ins.html
// 2. page 175 of https://www.unicode.org/versions/Unicode8.0.0/ch04.pdf
UnicodeLetter = { LETTER }
UnicodeDigit  = { DECIMAL_NUMBER }

/// Letters and digits

Letter       = { UnicodeLetter | "_" }
DecimalDigit = { '0'..'9' }
OctalDigit   = { '0'..'7' }
HexDigit     = { '0'..'9' | 'A'..'F' | 'a'..'f' }

/// Lexical elements

/// space (U+0020), horizontal tabs (U+0009), carriage returns (U+000D) and
/// newline (U+000A)
WHITESPACE = _{ "\u{0020}" | "\u{0009}" | "\u{000D}" | "\u{000A}" }

/// No comments containg `NewLine`.
// Refer TODO[3]
COMMENT = _{ "/*" ~ (!("*/" | NewLine) ~ ANY)* ~ "*/" }

Ident = @{ Letter ~ (Letter | UnicodeDigit)* }

IntLit        = @{ "0" | ('1'..'9' ~ ("_"? ~ DecimalDigits)?) }
DecimalDigits = @{ DecimalDigit ~ ("_"? ~ DecimalDigit)* }

/// Rune literals
RuneLit        = @{ "'" ~ (ByteValue | UnicodeValue) ~ "'" }
UnicodeValue   =  { LittleUValue | BigUValue | EscapedChar | UnicodeChar }
ByteValue      =  { HexByteValue | OctalByteValue }
OctalByteValue = @{ "\\" ~ OctalDigit{3} }
HexByteValue   = @{ "\\" ~ "x" ~ HexDigit{2} }
LittleUValue   = @{ "\\" ~ "u" ~ HexDigit{4} }
BigUValue      = @{ "\\" ~ "U" ~ HexDigit{8} }
EscapedChar    = @{ "\\" ~ ("a" | "b" | "f" | "n" | "r" | "t" | "v" | "\\" | "'" | "\"") }

/// string literals
StringLit = { RawStringLit | InterpretedStringLit }
// `UnicodeChar | NewLine` is equivalent to `ANY``
RawStringLit         = @{ "`" ~ (!"`" ~ ANY)* ~ "`" }
InterpretedStringLit = @{ "\"" ~ (!"\"" ~ (ByteValue | UnicodeValue))* ~ "\"" }

// Types
Type     = { TypeName | Tuple }
TypeName = { Ident }

// TODO: add it in spec
// Tuple
Tuple    = { "(" ~ ((Type ~ ",") | TypeList) ~ ")" }
TypeList = { Type ~ ("," ~ Type)+ }

// Function types
Signature      = { Parameters ~ Result? }
Result         = { Type }
Parameters     = { "(" ~ (ParameterList ~ ","?)? ~ ")" }
ParameterList  = { ParameterDecl ~ ("," ~ ParameterDecl)* }
ParameterDecl  = { IdentifierList? ~ Type }
IdentifierList = { Ident ~ ("," ~ Ident)* }

// Blocks
Block         = { "{" ~ StatementList ~ "}" }
StatementList = { (Statement ~ ";")* }

// Declarations
Declaration    = { ConstDecl | TypeDecl | VarDecl }
TopLevelDecl   = { Declaration | FunctionDecl }

// Const declartions
ConstDecl      = { "const" ~ (ConstSpec | "(" ~ (ConstSpec ~ ";")+ ~ ")") }
ConstSpec      = { IdentifierList ~ (Type? ~ "=" ~ ExpressionList)? }
ExpressionList = { Expression ~ ("," ~ Expression)* }

// Type declarations
TypeDecl = { "type" ~ ( TypeSpec | "(" ~ (TypeSpec ~ ";" )+ ~ ")" ) }
TypeSpec = { TypeDef }

// TODO: correct TypeDef spec (remove type parameters)
// Type definitions
TypeDef = { Ident ~ Type }

// Variable declaration
VarDecl = { "var" ~ (VarSpec | "(" ~ ( VarSpec ~ ";")* ~ ")") }
VarSpec = { IdentifierList ~ ((Type ~ ("=" ~ ExpressionList )?) | ("=" ~ ExpressionList)) }

// Function declaration
FunctionDecl = { "func" ~ FunctionName ~ Signature ~ FunctionBody? }
FunctionName = { Ident }
FunctionBody = { Block }

// TODO: update the spec
// Operands
Operand     = { Literal | OperandName | "(" ~ Expression ~ ")" }
Literal     = { BasicLit }
BasicLit    = { IntLit | RuneLit | StringLit }
OperandName = { Ident }

// Primary expressions
// ref: https://www.csd.uwo.ca/~mmorenom/CS447/Lectures/Syntax.html/node8.html
PrimaryExpr = { Operand ~ PrimaryExprPrime }
PrimaryExprPrime = { (Arguments ~ PrimaryExprPrime)? }

Arguments   = { "(" ~ (((Type ~ ("," ~ ExpressionList)?) | ExpressionList) ~ ","?)? ~ ")" }

// Operators
// ref: https://www.csd.uwo.ca/~mmorenom/CS447/Lectures/Syntax.html/node8.html
Expression = { UnaryExpr ~ ExpressionPrime }
ExpressionPrime = { (BinaryOp ~ Expression ~ ExpressionPrime)? }
UnaryExpr  = { (UnaryOp ~ UnaryExpr) | PrimaryExpr }

BinaryOp  = { RelOp | AddOp | MulOp }
RelOp     = { "==" | "!=" | "<=" | "<" | ">=" | ">" }
AddOp     = { "+" | "-" | "|" }
MulOp     = { "*" | "/" | "%" | "&" }

UnaryOp   = { "+" | "-" | "!" | "*" | "&" }

// Statements

Statement = { Declaration | SimpleStmt | ReturnStmt  | Block | IfStmt }

SimpleStmt = { ExpressionStmt | IncDecStmt | Assignment }

ExpressionStmt = { Expression }

IncDecStmt = { Expression ~ ( "++" | "--" ) }

Assignment = { ExpressionList ~ "=" ~ ExpressionList }

IfStmt = { "if" ~ (SimpleStmt ~ ";")? ~ Expression ~ Block ~ ("else" ~ (IfStmt | Block ))? }

ReturnStmt = { "return" ~ ExpressionList? }

